{% from "macros.nunjucks" import type2Test %}
/**
 * AUTOGENERATED - DO NOT EDIT DIRECTLY!
 */
 {# Note: The schema used with this template should have imports for the schema
   type and the "validate"/"validatePartial" functions.
 #}
{{imports2TS(document.imports, {
  '@quenk/noni/lib/data/jsonx': '_json',
  '@quenk/preconditions/lib/async': '_prec',
  '@quenk/preconditions/lib/async/record': '_recordPrec',
  '@quenk/preconditions/lib/async/array': '_arrayPrec'
  })
}}

//@ts-ignore: 6133
import { AsyncPrecondition } from '@quenk/preconditions/lib/async';

//@ts-ignore: 6133
import { Value } from '@quenk/noni/lib/data/jsonx';

{% for key in ["title", "collection", "table", "resource"] %}
  {% if isString(document[key]) %}
//@ts-ignore: 6133
const {{key}} = "{{document[key]}}";
  {% endif %}
{% endfor %}

//@ts-ignore: 6133
const _complete = _recordPrec.restrict;

//@ts-ignore: 6133
const _partial = _recordPrec.intersect;

/**
 * DataType check.
 * 
 * Used by template generation.
 * @private 
 */
export type DataType = {{document.title}};

{% set ctxname = document.title | classcase %}
{% set ctxname = ctxname + "CheckContext" %}
/**
 * {{ ctxname }} contains values and checks that can be used at the field level.
 */
export interface {{ ctxname }} {
  {% for key, value in (document.context or {}) %}
    '{{key}}': {{value}}
  {% endfor %}
}

{% set provider = document.title | classcase %}
{% set provider = provider + "CheckProvider" %}

/**
* {{ provider }} for the {{ document.title }} type.
 */
export type {{ provider }}
  = (ctx: {{ ctxname }}) => _prec.AsyncPrecondition<_json.Value, {{ document.title }}>
  ;

{% set ctxprops  %}
  {% for key, value in (document.context or {}) %}
    {{key}}{%- if not loop.last %},{% endif %}
  {% endfor %}
{% endset %}

/**
 * fieldChecks for {{document.title}} (AUTOGENERATED).
 */ 
export const fieldChecks = (_:{{ ctxname }}) : 
_prec.Preconditions<_json.Value, _json.Value> => {
 //@ts-ignore: 6133 
 let { {{ ctxprops }} } = _;
 return ({
  {% for key, value in document.properties %}

    '{{key}}': {% if (not value.readOnly) or hasChecks(value,"complete") -%}
               {{ type2Test(value, "complete") | trim -}}
               {% else %}
               _prec.identity
               {% endif %}{%- if not loop.last %},{% endif %}

  {% endfor %}
  });
}

/**
 * partialFieldChecks for {{ document.title }} (AUTOGENERATED).
 */ 
export const partialFieldChecks = (_: {{ ctxname }}):
_prec.Preconditions<_json.Value, _json.Value> => {
//@ts-ignore: 6133 
 let { {{ ctxprops }} } = _;
return ({
  {% for key,value in document.properties %}

    '{{key}}': {% if (not value.readOnly) or hasChecks(value,"partial") -%}
               {{ type2Test(value, "partial") | trim -}}
               {% else %}
                _prec.identity
               {% endif %}{%- if not loop.last %},{% endif %}

  {%- endfor -%}
  });
}

/**
 * check a value to determine if it is a correct {{ document.title }}
 * (AUTOGENERATED).
 */
 export const check:{{provider}}  = (_: {{ ctxname }}) :
 _prec.Precondition<_json.Value, {{ document.title }}> => {
 //@ts-ignore: 6133 
 let { {{ ctxprops }} } = _;
  {% if hasChecks(document,"complete") %}
    return _prec.and(_prec.and<_json.Value, {{ document.title }},{{ document.title }}>(
      _prec.async(validate), _recordPrec.restrict(fieldChecks(_))),
      _prec.every<{{ document.title }},{{ document.title }}>({{ getChecks(document,"complete") | join(',') }})
     );
  {% else %}
    return _prec.and<_json.Value, {{ document.title }},{{ document.title }}>(
      _prec.async<_json.Value, {{ document.title }}>(validate),
       _recordPrec.restrict(fieldChecks(_)));
  {% endif %}
}

/**
 * checkPartial is like check but only checks the fields encountered.
 * (AUTOGENERATED).
 */
 export const checkPartial:{{provider}} = (_: {{ ctxname }}) :
 _prec.Precondition<_json.Value, Partial<{{document.title}}>> => {
 //@ts-ignore: 6133 
 let { {{ ctxprops }} } = _;
  {% if hasChecks(document, "partial") %}
    return _prec.and(_prec.and<_json.Value, {{document.title}},{{document.title}}>(
      _prec.async(validatePartial),
      _recordPrec.intersect(partialFieldChecks(_))),
    _prec.every({{getChecks(document,"partial") | join(',')}}));
  {% else %}
    return _prec.and<_json.Value, {{document.title}},{{document.title}}>(_prec.async<_json.Value,{{document.title}}>(validatePartial), 
   _recordPrec.intersect(partialFieldChecks(_)));  
 {% endif %}
 }
